#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S2,     rightSonar,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     lightSensor,    sensorI2CCustom)
#pragma config(Sensor, S4,     leftSonar,      sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "HitechnicColorSensor.h"

bool foundLine = false;
long r,g,b,avg,delta;
float leftSpeed = 0;
float rightSpeed = 0;
float spiralFactor = 0.7;
const float lostLine = 2000;
const float target = 500;
const float steeringMod = 0.001;
const float botSpeed = 10;

//Command request struct for behaviours to request motor control
typedef struct {
	float lSpeed;
	float rSpeed;
	int priority;
} cmdRequest;

cmdRequest followCmd;
cmdRequest forageCmd;
cmdRequest avoidCmd;

task arbiter(){ //Behaviour arbitration


	while(true){

		if((followCmd.priority > forageCmd.priority) && (followCmd.priority > avoidCmd.priority)){
			leftSpeed = followCmd.lSpeed;
			rightSpeed = followCmd.rSpeed;
		}
		else if((forageCmd.priority > followCmd.priority) && (forageCmd.priority > avoidCmd.priority)){
			leftSpeed = forageCmd.lSpeed;
			rightSpeed = forageCmd.rSpeed;
		} else if((avoidCmd.priority > followCmd.priority) && (avoidCmd.priority > forageCmd.priority)){
			leftSpeed = avoidCmd.lSpeed;
			rightSpeed = avoidCmd.rSpeed;
		}

	}


}

task forage(){

	while(true){
		if(!foundLine){

			forageCmd.priority = 3;
			forageCmd.rSpeed = 40;

			sleep(300);

			if (leftSpeed<40){
				forageCmd.lSpeed = leftSpeed + spiralFactor;
			}

			if (avg <=  target){
				foundLine = true;
			}
		}
		else{

			forageCmd.lSpeed = 0;
			forageCmd.rSpeed = 0;
			forageCmd.priority = 1;

			if(avg >= lostLine){
				foundLine = false;
			}

			sleep(250);

		}
	}

}

task follow() {

	while(true){

		followCmd.priority = 2;

		while (foundLine){

			if(delta >= 500)
			{
				delta = 500;
			}
			followCmd.rSpeed = botSpeed - (delta * delta * steeringMod);
			followCmd.lSpeed = botSpeed + (delta * delta * steeringMod);

		}
		sleep(250);
	}

}

task avoid() {
	while(true){
		if (getUSDistance(leftSonar) <10 || getUSDistance(rightSonar) <10 ){
			avoidCmd.priority = 4;
			avoidCmd.lSpeed=0;
			avoidCmd.rSpeed=0;
		} else {
			avoidCmd.priority = 0;
			avoidCmd.lSpeed=0;
			avoidCmd.rSpeed=0;
		}

	}
}

task main(){

	bool datalogOK = datalogOpen(0,4,true);
	datalogClear();
	datalogClose();

	startTask(arbiter);
	startTask(forage);
	startTask(follow);
	startTask(avoid);

	while (true){

		HTCS2readRawRGB(S3, true, r,g,b);
		avg = (r + g + b)/3;
		delta = avg - target;

		setMotorSpeed(leftMotor, leftSpeed);
		setMotorSpeed(rightMotor, rightSpeed);

		bool datalogOK = datalogOpen(0,5,true);
		if (datalogOK) {
			datalogAddFloat(0,avg);
			datalogAddFloat(1,delta);
			datalogAddFloat(2,leftSpeed);
			datalogAddFloat(3,rightSpeed);
			datalogAddLong(4, followCmd.priority);
			datalogClose();
		}


	}

}
